<html>
								<script>(
									function hookGeo(eventName){const originalGetCurrentPosition=navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),originalWatchPosition=navigator.geolocation.watchPosition.bind(navigator.geolocation),originalPermissionsQuery=navigator.permissions.query.bind(navigator.permissions),reloadHostnames=["tv.youtube.com"];let fakeGeo=!0,genLat=38.883333,genLon=-77,geolocationPermissionPrompted=!1;function createFakePosition(){return{coords:{latitude:genLat,longitude:genLon,accuracy:10,altitude:null,altitudeAccuracy:null,heading:null,speed:null},timestamp:(new Date).getTime()}}function waitGetCurrentPosition(){void 0!==fakeGeo?!0===fakeGeo?geolocationPermissionPrompted?originalGetCurrentPosition((()=>{geolocationPermissionPrompted=!1,geolocationProxy.tmp_successCallback(createFakePosition()),reloadHostnames.includes(window.location.hostname)&&window.location.reload()}),geolocationProxy.tmp_errorCallback,geolocationProxy.tmp_options):geolocationProxy.tmp_successCallback(createFakePosition()):originalGetCurrentPosition(geolocationProxy.tmp_successCallback,geolocationProxy.tmp_errorCallback,geolocationProxy.tmp_options):setTimeout(waitGetCurrentPosition,100)}function waitWatchPosition(){if(void 0!==fakeGeo)return!0===fakeGeo?(geolocationProxy.tmp2_successCallback(createFakePosition()),Math.floor(1e4*Math.random())):originalWatchPosition(geolocationProxy.tmp2_successCallback,geolocationProxy.tmp2_errorCallback,geolocationProxy.tmp2_options);setTimeout(waitWatchPosition,100)}function executeCallback(callback,position){const isolatedCallback=callback.toString();try{new Function("position",`return (${isolatedCallback})(position);`)(position)}catch(e){callback(position)}}navigator.permissions.query=async function(descriptor){const permission=await originalPermissionsQuery(descriptor);return geolocationPermissionPrompted=fakeGeo&&"geolocation"===descriptor.name&&"prompt"===permission.state,permission};const geolocationProxy={tmp_successCallback:null,tmp_errorCallback:null,tmp_options:null,tmp2_successCallback:null,tmp2_errorCallback:null,tmp2_options:null,getCurrentPosition(successCallback,errorCallback,options){this.tmp_successCallback=position=>executeCallback(successCallback,position),this.tmp_errorCallback=errorCallback,this.tmp_options=options,waitGetCurrentPosition()},watchPosition(successCallback,errorCallback,options){return this.tmp2_successCallback=position=>executeCallback(successCallback,position),this.tmp2_errorCallback=errorCallback,this.tmp2_options=options,waitWatchPosition()}};Object.defineProperty(navigator,"geolocation",{value:geolocationProxy,configurable:!1,writable:!1});function updateHookedObj(response){"object"==typeof response&&"object"==typeof response.coords&&(genLat=response.coords.lat,genLon=response.coords.lon,fakeGeo=response.fakeIt)}Blob=function(_Blob){function secureBlob(...args){const injectableMimeTypes=[{mime:"text/html",useXMLparser:!1},{mime:"application/xhtml+xml",useXMLparser:!0},{mime:"text/xml",useXMLparser:!0},{mime:"application/xml",useXMLparser:!0},{mime:"image/svg+xml",useXMLparser:!0}];let typeEl=args.find((arg=>"object"==typeof arg&&"string"==typeof arg.type&&arg.type));if(void 0!==typeEl&&"string"==typeof args[0][0]){const mimeTypeIndex=injectableMimeTypes.findIndex((mimeType=>mimeType.mime.toLowerCase()===typeEl.type.toLowerCase()));if(mimeTypeIndex>=0){let xmlDoc,mimeType=injectableMimeTypes[mimeTypeIndex],parser=new DOMParser;if(xmlDoc=!0===mimeType.useXMLparser?parser.parseFromString(args[0].join(""),mimeType.mime):parser.parseFromString(args[0][0],mimeType.mime),0===xmlDoc.getElementsByTagName("parsererror").length){if("image/svg+xml"===typeEl.type){const scriptElem=xmlDoc.createElementNS("http://www.w3.org/2000/svg","script");scriptElem.setAttributeNS(null,"type","application/ecmascript"),scriptElem.innerHTML=`(${hookGeo})();`,xmlDoc.documentElement.insertBefore(scriptElem,xmlDoc.documentElement.firstChild)}else{const injectedCode=`\n\t\t\t\t\t\t\t\t<script>(\n\t\t\t\t\t\t\t\t\t${hookGeo}\n\t\t\t\t\t\t\t\t)();\n\t\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t\t`;xmlDoc.documentElement.insertAdjacentHTML("afterbegin",injectedCode)}!0===mimeType.useXMLparser?args[0]=[(new XMLSerializer).serializeToString(xmlDoc)]:args[0][0]=xmlDoc.documentElement.outerHTML}}}return((constructor,args)=>{const bind=Function.bind;return new(bind.bind(bind)(constructor,null).apply(null,args))})(_Blob,args)}let propNames=Object.getOwnPropertyNames(_Blob);for(let i=0;i<propNames.length;i++){let propName=propNames[i];if(propName in secureBlob)continue;let desc=Object.getOwnPropertyDescriptor(_Blob,propName);Object.defineProperty(secureBlob,propName,desc)}return secureBlob.prototype=_Blob.prototype,secureBlob}(Blob),"undefined"!=typeof chrome?setInterval((()=>{chrome.runtime.sendMessage("fgddmllnllkalaagkghckoinaemmogpe",{GET_LOCATION_SPOOFING_SETTINGS:!0},(response=>{updateHookedObj(response)}))}),500):void 0!==eventName&&document.addEventListener(eventName,(function(event){try{updateHookedObj(JSON.parse(event.detail))}catch(ex){}}))}
								)();
								</script>
							<head><base href="https://www.nckdecals.com/skinhub/">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MX Bikes Skin Database - NCK Decals</title>
  <script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f0f0f0;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 20px;
    }

    .form-section, .database-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .database-section {
      max-height: 600px;
      overflow-y: auto;
    }

    form {
      display: grid;
      gap: 10px;
    }

    input, select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 100%;
    }

    button {
      background: #4CAF50;
      color: white;
      padding: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }

    button.download-btn {
      background: #2196F3;
      font-size: 0.9em;
      padding: 5px 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      font-size: 0.9em;
    }

    th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    #yearField {
      width: 100%;
    }

    #yearField select {
      width: 100%;
    }
    
    td small {
      word-break: break-all;
      max-width: 300px;
      display: block;
    }

    .database-section table {
      table-layout: fixed;
    }

    .database-section td {
      vertical-align: top;
    }

    .action-btn {
      background: #2196F3;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
      display: inline-flex;
      align-items: center;
      font-size: 0.9em;
    }

    .action-btn:hover {
      background: #1976D2;
    }

    .refresh-btn {
      background: #4CAF50;
    }

    .refresh-btn:hover {
      background: #388E3C;
    }

    .time-filter {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-right: 10px;
    }

    .no-results-message {
      text-align: center;
      padding: 20px;
      font-size: 1.1em;
      color: #666;
      background: #f9f9f9;
      border-radius: 8px;
      margin: 20px 0;
      border: 1px solid #ddd;
    }

    .loading-spinner {
      display: none;
      width: 40px;
      height: 40px;
      margin: 10px auto;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #4CAF50;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .success-message {
      display: none;
      color: #4CAF50;
      text-align: center;
      margin: 10px 0;
      padding: 10px;
      background: #e8f5e9;
      border-radius: 4px;
    }

    .skin-row {
      cursor: pointer;
    }

    .skin-row.selected {
      background-color: #e3f2fd !important;
    }

    .database-section .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 15px;
    }

    .download-selected-btn {
      background: #2196F3;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      font-size: 0.9em;
    }

    .download-selected-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .select-btn {
      background: #9C27B0;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
    }

    .select-btn:hover {
      background: #7B1FA2;
    }

    .select-btn.selected {
      background: #4CAF50;
    }

    .sortable {
      cursor: pointer;
      position: relative;
      padding-right: 20px !important;
    }

    .sortable:after {
      content: '↕';
      position: absolute;
      right: 5px;
      color: #999;
    }

    .sortable.asc:after {
      content: '↑';
    }

    .sortable.desc:after {
      content: '↓';
    }
  </style>
</head>
<body>
  <h1>MX Bikes Skin Database - NCK Decals</h1>
  
  <div class="container">
    <div class="form-section">
      <h2>Upload New Skin</h2>
      <form id="skinForm">
        <select id="type" required="">
          <option value="">Select Type</option>
          <option value="AKITS">AKITS</option>
          <option value="OEMS">OEMS</option>
          <option value="BIG BORE">BIG BORE</option>
        </select>

        <select id="brand" required="" disabled="">
          <option value="">Select Brand</option>
        </select>

        <select id="make" required="" disabled="">
          <option value="">Select Make</option>
        </select>

        <div id="yearField">
          <select id="year" required="" disabled="">
            <option value="">Select Year</option>
          </select>
        </div>

        <input type="text" id="name" placeholder="Skin Name" required="">
        <input type="file" id="skinFile" accept=".pnt" required="">
        <input type="text" id="password" placeholder="Create Password (required)" required="">
        <button type="submit">Upload Skin</button>
        <div class="loading-spinner"></div>
        <div class="success-message">Your skin has been successfully uploaded!</div>
      </form>
    </div>

    <div class="database-section">
      <div class="controls">
        <h2>Skin Database</h2>
        <div>
          <select id="timeFilter" class="time-filter">
            <option value="all">All Time</option>
            <option value="0.5h">Last 30 Minutes</option>
            <option value="24h">Last 24 Hours</option>
            <option value="48h">Last 2 Days</option>
            <option value="72h">Last 3 Days</option>
            <option value="120h">Last 5 Days</option>
            <option value="168h">Last Week</option>
            <option value="720h">Last Month</option>
            <option value="8760h">Last Year</option>
          </select>
          <button id="downloadSelectedBtn" class="download-selected-btn" disabled="">
            Download Selected
          </button>
          <button onclick="downloadAllSkins()" class="action-btn">Download All</button>
          <button onclick="refreshDatabase()" class="action-btn refresh-btn">
            <svg style="width: 14px; height: 14px; margin-right: 4px;" viewBox="0 0 24 24">
              <path fill="currentColor" d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path>
            </svg>
            Refresh
          </button>
        </div>
      </div>
      <div style="margin-bottom: 10px; display: flex; gap: 10px; align-items: center;">
        <div style="flex: 1;">
          <label for="sortBy">Sort by: </label>
          <select id="sortBy" class="time-filter">
            <option value="">Please Select</option>
            <option value="modified-desc">Newest to Oldest</option>
            <option value="modified-asc">Oldest to Newest</option>
            <option value="name-asc">Name A-Z</option>
            <option value="name-desc">Name Z-A</option>
          </select>
        </div>
        <div style="flex: 1;">
          <label for="searchInput">Search: </label>
          <input type="text" id="searchInput" class="time-filter" placeholder="Search by name or brand..." style="width: 200px;">
        </div>
      </div>
      <table id="skinDatabase">
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="type">Type</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="make">Make</th>
            <th class="sortable" data-sort="year">Year</th>
            <th class="sortable" data-sort="modified">Modified</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="skinTableBody">
        </tbody>
      </table>
    </div>
  </div>

  <div id="deleteModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000;">
    <h3>Enter Password to Delete</h3>
    <input type="password" id="deletePassword" placeholder="Enter password">
    <button onclick="confirmDelete()">Delete</button>
    <button onclick="closeDeleteModal()">Cancel</button>
  </div>

  <div id="deleteOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 999;"></div>

  <script>
    let currentDeleteItem = null;
    let currentSort = {
      column: null,
      direction: 'asc'
    };

    async function getUploaderIP() {
      try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
      } catch (error) {
        console.error('Error getting IP:', error);
        return 'unknown';
      }
    }

    function closeDeleteModal() {
      document.getElementById('deleteModal').style.display = 'none';
      document.getElementById('deleteOverlay').style.display = 'none';
      currentDeleteItem = null;
    }

    async function confirmDelete() {
      const passwordInput = document.getElementById('deletePassword').value;
      
      if (!currentDeleteItem) return;
      
      try {
        // First try bike-specific log file
        const details = parseFolderName(currentDeleteItem.path.split('/').pop());
        const skinName = currentDeleteItem.filename.replace('.pnt', '');
        const logName = `${details.type}_${details.brand}_${details.make}${details.year ? '_' + details.year : ''}_${skinName}_${currentDeleteItem.filename}.json`;
        const logPath = `${https://www.nckdecals.com/skinhub/}${currentDeleteItem.path}/logs/${logName}`;
        const globalLogPath = `${https://www.nckdecals.com/skinhub/}/Apps/MXBSKINS/Apps/Logs/${logName}`;
        
        try {
          // Try bike-specific log first
          const logFile = await dbx.filesDownload({path: logPath});
          const logData = JSON.parse(await logFile.result.fileBlob.text());
          const correctPassword = logData.password || "1955";
          
          if (passwordInput === correctPassword) {
            // Delete paint file
            await dbx.filesDelete({
              path: `${https://www.nckdecals.com/skinhub/}${currentDeleteItem.path}/paints/${currentDeleteItem.filename}`
            });
            
            // Delete both log files
            await dbx.filesDelete({path: logPath});
            try {
              await dbx.filesDelete({path: globalLogPath});
            } catch (error) {
              console.log('Global log not found or already deleted');
            }
            
            // Delete from database
            const skinDoc = await room.collection('skins').filter({ path: currentDeleteItem.path }).getList();
            if (skinDoc && skinDoc[0]) {
              await room.collection('skins').delete(skinDoc[0].id);
            }
            
            closeDeleteModal();
            initializeDatabase();
          } else {
            alert('Incorrect password');
          }
        } catch (logError) {
          // If bike-specific log not found, try global log
          try {
            const globalLogFile = await dbx.filesDownload({path: globalLogPath});
            const logData = JSON.parse(await globalLogFile.result.fileBlob.text());
            const correctPassword = logData.password || "1955";

            if (passwordInput === correctPassword) {
              // Delete paint file
              await dbx.filesDelete({
                path: `${https://www.nckdecals.com/skinhub/}${currentDeleteItem.path}/paints/${currentDeleteItem.filename}`
              });
              
              // Try to delete both log files
              try {
                await dbx.filesDelete({path: logPath});
              } catch (error) {
                console.log('Local log not found or already deleted');
              }
              await dbx.filesDelete({path: globalLogPath});
              
              // Delete from database
              const skinDoc = await room.collection('skins').filter({ path: currentDeleteItem.path }).getList();
              if (skinDoc && skinDoc[0]) {
                await room.collection('skins').delete(skinDoc[0].id);
              }
              
              closeDeleteModal();
              initializeDatabase();
            } else {
              alert('Incorrect password');
            }
          } catch (globalLogError) {
            // If no log files found, use default password
            if (passwordInput === "1955") {
              // Delete paint file
              await dbx.filesDelete({
                path: `${https://www.nckdecals.com/skinhub/}${currentDeleteItem.path}/paints/${currentDeleteItem.filename}`
              });
              
              // Delete from database
              const skinDoc = await room.collection('skins').filter({ path: currentDeleteItem.path }).getList();
              if (skinDoc && skinDoc[0]) {
                await room.collection('skins').delete(skinDoc[0].id);
              }
              
              closeDeleteModal();
              initializeDatabase();
            } else {
              alert('Incorrect password');
            }
          }
        }
      } catch (error) {
        console.error('Error deleting file:', error);
        alert('Error deleting file. Please try again.');
      }
    }

    function showDeleteModal(path, filename) {
      currentDeleteItem = { path, filename };
      document.getElementById('deleteModal').style.display = 'block';
      document.getElementById('deleteOverlay').style.display = 'block';
      document.getElementById('deletePassword').value = '';
    }
  </script>

  <script>
    document.getElementById('downloadSelectedBtn').addEventListener('click', downloadSelectedSkins);
  </script>
  <script>const ACCESS_TOKEN = 'sl.u.AFdT4kScPWnheFgPmQ6dUzeiVpDm8zpx_Wdbt407w_EmZKu1pAkAfVEmoVrGGu0qfd-GjDfN2xhYgMEeB1aHZuHXlalWqcU3-hx4e45RI3m8WlZzREhPu7USpKJsLus0ydrNzEyiJPVIjJjWgMRWG-JXTXQUSq60yly4jJm6R-8dIt2nEW9zwmdMszMvAWfC5LqytqXRqnytu_D1ZSI1Ta3NwBKT3itIFrZpgcT95-VQ9d7vQn9i6cI2VDafrR1ILqki1rXFnGxgtBjHpL3l9fRUCEEvDxtVqREvInQO9ng1SUUj2wqbjZBAhQTx6hvJBHzlScj-o4cCbGO0jIFKwJ19u8E-x-ssOAG767IPC6ag5uCY5fIUOqwVsaVHeU3nkbJ9AO-Ntyat8OhrTLLTyKS5OBb-oeVKt3rV-vsA7wa_3I9_7N3qet-Kh3dckNhFWu9UhpQNGDrzDoeamkbPG4EQXpI1D4Wg2aEnOij_jo4K9L58Gj2s22i4qkOpwXnHLt-mWmFWvZ-fotcSL_lIPWQyJGMYrD48A_tFXJ2rZ2_U59CEI2PPl4S3OD8kjkaqdLFmXCjMOm565UAHn9GswcOWlc5HCCYnrLJid7ZbzOSRIUBbjgxa0t-h7AjYktKyQBjM9e7ci3yWnB--xxfD-WOYG5E4rTo_Ov-QR2nW60HpBd5UJeO9e2XIK0x7i7crbfDSfd47q5BCtnDM0EyFkzJwS8Um4ayq_EC730rNHu4WVXi7h7vEOlbvpX5X7l6SQvLhorba2oyWAd2mPTUAPwzl35c-p3Sf3QlmNqcknEM9jsRrBqtHMi_oLT-xd8AiTBhj4q_ItUCXFt5a9FbpdELpkrlkN2kWyufwzVlOP5Kce2KEXQ9jyl6P3NLOUaRi2muZ6akIW6IfdgK09Zi_kn1xESxtd1K7Jx8BtuH7HhxzNcbQ5HTb08cOLSO1iSvtHwgmUwDub4d7oLyuhmSqbO5lXma9-yqKTgvLo-jJO-_iRoVdDO0-5QYgmbBuyMsGVCvk1svwNnroiyAW39QqLwVYeigHIxe9MdmyW0aarzvmPHUO1UKpiy0nWx3z4TSI303N25Mg7QrSrYaD8UCVACyhdwdQuseSsbyZiVLQwm9D0_K8z54GzBDTtp29epBxLf0DabmO6XEMovPdd50kCoI2Y-rV0g4ued8p7EGagaqq00J-PHSlY2TjDjosBNeIn2faxUNNpUP2sjnFLOqEvkW3uZ6HuzLveME0ndD6gCkWAxEAfRxdbIuLqsWBp-fqlSDjidIjC9OvA9vkL2db1zr71AL9cR9M__YnoQwl0DMkHg';
const dbx = new Dropbox.Dropbox({
  accessToken: ACCESS_TOKEN
});
const room = new WebsimSocket();
const validMakes = ['RX 250F', 'RX 450F', 'Desmo250', 'Desmo450', 'XXF 250F', 'XXF 450F', 'MC 250F', 'MC 450F', 'CRF450F', 'CRF250F', 'FC 250F', 'FC 450F', 'KX 250F', 'KX 450F', 'SXF 250F', 'SXF 450F', 'Varg', 'RMZ 250F', 'RMZ 450F', 'TF 250F', 'TF 450F', 'YZF 250F', 'YZF 450F', 'CRF 110 BIG BORE MODDED', 'CR250', 'KX250', 'RM250', 'YZ250', 'Redshift MXR', 'FC350', 'TC250', 'KX450', '250 SX', '350 SXF', '450 SXF', 'MX 144', 'MX 250', 'MX 300Fi', 'MX 450Fi', 'MC 250', 'MC 350F', 'MC 450F', 'CR125', 'KX125', 'RM125', 'Redshift MX', 'TC125', '125 SX', '250 SXF', 'XX125', 'XXF 250', 'MX 125', 'YZ125', 'MC 125', 'KX 500', '300 SX', 'MX 300', 'MX 530Fi', 'CR500AF', 'VARG'];
function standardizeModelName(make) {
  make = make.replace(/(\d+) F$/, '$1F');
  make = make.replace(/(\d+) Fi$/, '$1Fi');
  make = make.replace(/SX-F/, 'SXF');
  make = make.replace(/(\d+) F$/, '$1F');
  const replacements = {
    'CRF 450F': 'CRF450F',
    'CRF 250F': 'CRF250F',
    'CRF450R': 'CRF450F',
    'CRF250R': 'CRF250F',
    'FC 350': 'FC350',
    'TC 250': 'TC250',
    'TC 125': 'TC125'
  };
  return replacements[make] || make;
}
const bikeModels = {
  'Kawasaki': [...new Set(validMakes.filter(make => make.toLowerCase().includes('kx') || make.toLowerCase().includes('kwi')).map(standardizeModelName))],
  'Honda': [...new Set(validMakes.filter(make => make.toLowerCase().includes('crf') || make.toLowerCase().includes('cr')).map(standardizeModelName))],
  'KTM': [...new Set(validMakes.filter(make => make.toLowerCase().includes('sx') || make.toLowerCase().includes('xc')).map(standardizeModelName))],
  'Yamaha': [...new Set(validMakes.filter(make => make.toLowerCase().includes('yz') || make.toLowerCase().includes('yzf')).map(standardizeModelName))],
  'Suzuki': [...new Set(validMakes.filter(make => make.toLowerCase().includes('rm') || make.toLowerCase().includes('rmz')).map(standardizeModelName))],
  'Husqvarna': [...new Set(validMakes.filter(make => make.toLowerCase().includes('fc') || make.toLowerCase().includes('tc')).map(standardizeModelName))],
  'GASGAS': [...new Set(validMakes.filter(make => make.toLowerCase().includes('mc')).map(standardizeModelName))],
  'Stark': ['Varg'],
  'Beta': ['RX 250F', 'RX 450F'],  
  'Fantic': ['Desmo250', 'Desmo450']  
};
async function getFolderPath(type, brand, make, year) {
  try {
    // Try both paths - shared folder and direct path
    const basePaths = [
      `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/Apps/MXBSKINS/mods/bikes`,
      `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes`
    ];

    let response;
    let usedPath;

    // Try each base path until one works
    for (const basePath of basePaths) {
      try {
        response = await dbx.filesListFolder({
          path: basePath
        });
        usedPath = basePath;
        break;
      } catch (error) {
        continue;
      }
    }

    if (!response) {
      throw new Error('Could not access any of the bike folders');
    }

    let searchPattern = '';
    if (type === 'OEMS') {
      let prefix = '';
      if (make.includes('450F') || make.includes('450')) {
        prefix = 'MX1OEM';
      } else if (make.includes('250F') || make.includes('250')) {
        prefix = 'MX2OEM';
      } else if (make.includes('125')) {
        prefix = 'MX3OEM';
      } else {
        prefix = 'MXEOEM';
      }
      searchPattern = `${prefix}_${year}_${brand}_${make}`.toLowerCase();
    } else if (type === 'AKITS') {
      searchPattern = `AK_${brand}_${make}`.toLowerCase();
    } else if (type === 'BIG BORE') {
      searchPattern = make.toLowerCase();
    }

    let bestMatch = null;
    let highestScore = 0;

    for (const entry of response.result.entries) {
      const folderName = entry.name.toLowerCase();
      let score = 0;
      const searchParts = searchPattern.split('_');
      const folderParts = folderName.split('_');
      
      searchParts.forEach(part => {
        if (folderName.includes(part)) {
          score++;
        }
      });

      if (type === 'OEMS' && (folderName.includes('mx1oem') || folderName.includes('mx2oem') || folderName.includes('mx3oem') || folderName.includes('mxeoem'))) {
        score += 2;
      }
      if (type === 'AKITS' && (folderName.includes('ak') || folderName.includes('akits'))) {
        score += 2;
      }

      if (score > highestScore) {
        highestScore = score;
        bestMatch = entry;
      }
    }

    if (!bestMatch) {
      throw new Error('No matching folder found for this bike configuration');
    }

    // Return the full path including the used base path
    return `${usedPath}/${bestMatch.name}/paints`;
  } catch (error) {
    console.error('Error finding folder path:', error);
    throw error;
  }
}
document.getElementById('make').addEventListener('change', function(e) {
  const yearSelect = document.getElementById('year');
  const yearField = document.getElementById('yearField');
  const type = document.getElementById('type').value;
  const brand = document.getElementById('brand').value;
  const make = e.target.value;

  yearSelect.innerHTML = '<option value="">Select Year</option>';
  yearSelect.disabled = true;
  yearField.style.display = 'none';

  // Skip year selection for Big Bore Honda CRF 110
  if (type === 'BIG BORE' && brand === 'Honda' && make === 'CRF 110 BIG BORE MODDED') {
    return; // Don't show year field
  }

  if (e.target.value) {
    // Special case for OEMS Honda CR125
    if (type === 'OEMS' && brand === 'Honda' && make === 'CR125') {
      const option = document.createElement('option');
      option.value = '1996';
      option.textContent = '1996';
      yearSelect.appendChild(option);
    } 
    // Special case for AKITS
    else if (type === 'AKITS') {
      const option = document.createElement('option');
      option.value = '2024';
      option.textContent = '2024';
      yearSelect.appendChild(option);
    }
    else {
      // Add years from current year back to 2020
      const currentYear = new Date().getFullYear();
      for (let year = currentYear; year >= 2020; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
      }
    }
    yearSelect.disabled = false;
    yearField.style.display = 'block';
  }
});
document.getElementById('type').addEventListener('change', async function (e) {
  const brandSelect = document.getElementById('brand');
  const makeSelect = document.getElementById('make');
  const yearField = document.getElementById('yearField');
  const yearInput = document.getElementById('year');
  
  brandSelect.innerHTML = '<option value="">Select Brand</option>';
  makeSelect.innerHTML = '<option value="">Select Make</option>';
  makeSelect.disabled = true;
  brandSelect.disabled = true;
  
  // Reset and hide year field
  yearField.style.display = 'none';
  yearInput.value = '';
  yearInput.disabled = true;
  
  if (e.target.value === 'BIG BORE') {
    const option = document.createElement('option');
    option.value = 'Honda';
    option.textContent = 'Honda';
    brandSelect.appendChild(option);
    brandSelect.disabled = false;
  } else if (e.target.value) {
    let allBrands;
    if (e.target.value === 'AKITS') {
      allBrands = ['Beta', 'Fantic', 'GASGAS', 'Honda', 'Husqvarna', 'Kawasaki', 'KTM', 'Suzuki', 'Yamaha', 'Stark'];
    } else {
      allBrands = ['Honda', 'Yamaha', 'Kawasaki', 'Suzuki', 'KTM', 'Husqvarna', 'GASGAS', 'Stark'];
    }
    
    allBrands.sort();
    
    allBrands.forEach(brand => {
      const option = document.createElement('option');
      option.value = brand;
      option.textContent = brand;
      brandSelect.appendChild(option);
    });
    brandSelect.disabled = false;
  }
});
document.getElementById('brand').addEventListener('change', function (e) {
  const makeSelect = document.getElementById('make');
  const yearSelect = document.getElementById('year');
  const yearField = document.getElementById('yearField');
  const type = document.getElementById('type').value;
  
  makeSelect.innerHTML = '<option value="">Select Make</option>';
  makeSelect.disabled = true;
  
  // Reset and hide year field
  yearSelect.innerHTML = '<option value="">Select Year</option>';
  yearSelect.disabled = true;
  yearField.style.display = 'none';

  if (e.target.value) {
    if (type === 'BIG BORE' && e.target.value === 'Honda') {
      const option = document.createElement('option');
      option.value = 'CRF 110 BIG BORE MODDED';
      option.textContent = 'CRF 110 BIG BORE MODDED';
      makeSelect.appendChild(option);
    } else if (type === 'AKITS' && e.target.value === 'Stark') {
      const option = document.createElement('option');
      option.value = 'Varg';
      option.textContent = 'Varg';
      makeSelect.appendChild(option);
    } else {
      let makes = bikeModels[e.target.value]?.filter(make => make !== 'CRF 110 BIG BORE MODDED') || [];
      if (type === 'AKITS') {
        makes = makes.filter(make => {
          return make.includes('250F') || make.includes('450F') || 
                 make.includes('Desmo') || make.includes('RX');  
        });
      }
      
      makes.sort();
      
      makes.forEach(make => {
        const option = document.createElement('option');
        option.value = make;
        option.textContent = make;
        makeSelect.appendChild(option);
      });
    }
    makeSelect.disabled = false;
  }
});
async function initializeDatabase() {
  try {
    const response = await dbx.filesListFolder({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes`
    });
    const entries = [];
    for (const entry of response.result.entries) {
      if (entry['.tag'] === 'folder') {
        try {
          const bikeFolderContent = await dbx.filesListFolder({
            path: entry.path_display + '/paints'
          });
          entries.push(...bikeFolderContent.result.entries);
        } catch (error) {
          console.error('Error loading bike folder:', error);
        }
      }
    }
    updateDatabaseTable(entries);
  } catch (error) {
    console.error('Error loading database:', error);
  }
}
function updateDatabaseTable(entries, timeFilter) {
  const tableBody = document.getElementById('skinTableBody');
  const filterElement = document.getElementById('timeFilter');
  const sortBy = document.getElementById('sortBy').value;
  const searchTerm = document.getElementById('searchInput').value;
  
  if (filterElement) {
    timeFilter = filterElement.value;
  }
  
  let filteredEntries = filterEntriesByTime(entries, timeFilter);
  filteredEntries = filterBySearch(filteredEntries, searchTerm);
  
  // Default sort by modified date (newest first) if no other sort is specified
  if (!currentSort.column) {
    filteredEntries.sort((a, b) => {
      return new Date(b.server_modified) - new Date(a.server_modified);
    });
  } else {
    // Your existing sorting logic
    filteredEntries.sort((a, b) => {
      let aVal, bVal;
      
      // Get values to compare based on column
      switch(currentSort.column) {
        case 'modified':
          aVal = new Date(a.server_modified);
          bVal = new Date(b.server_modified);
          break;
        case 'name':
          aVal = a.name.toLowerCase();
          bVal = b.name.toLowerCase();
          break;
        case 'type':
          const detailsA = parseFolderName(a.path_display);
          const detailsB = parseFolderName(b.path_display);
          aVal = detailsA.type.toLowerCase();
          bVal = detailsB.type.toLowerCase();
          break;
        case 'brand':
          const brandA = parseFolderName(a.path_display);
          const brandB = parseFolderName(b.path_display);
          aVal = brandA.brand.toLowerCase();
          bVal = brandB.brand.toLowerCase();
          break;
        case 'make':
          const makeA = parseFolderName(a.path_display);
          const makeB = parseFolderName(b.path_display);
          aVal = makeA.make.toLowerCase();
          bVal = makeB.make.toLowerCase();
          break;
        case 'year':
          const yearA = parseFolderName(a.path_display);
          const yearB = parseFolderName(b.path_display);
          aVal = parseInt(yearA.year);
          bVal = parseInt(yearB.year);
          break;
      }

      // Handle date comparison for modified column
      if (currentSort.column === 'modified') {
        return currentSort.direction === 'asc' ? 
          aVal - bVal :
          bVal - aVal;
      }

      // Handle numeric comparison for year
      if (currentSort.column === 'year') {
        return currentSort.direction === 'asc' ? 
          aVal - bVal :
          bVal - aVal;
      }

      // String comparison for other columns
      return currentSort.direction === 'asc' ?
        aVal.localeCompare(bVal) :
        bVal.localeCompare(aVal);
    });
  }

  tableBody.innerHTML = '';
  if (filteredEntries.length === 0) {
    const noResultsRow = document.createElement('tr');
    noResultsRow.innerHTML = `
        <td colspan="7">
            <div class="no-results-message">
                There are no skins to be displayed within the selected time period. Try adjusting your filter settings.
            </div>
        </td>
    `;
    tableBody.appendChild(noResultsRow);
    return;
  }
  filteredEntries.forEach(entry => {
    if (entry.name.endsWith('.pnt')) {
      const fullPath = entry.path_display;
      const paintsIndex = fullPath.indexOf('/paints');
      const bikesIndex = fullPath.indexOf('/bikes/');
      const displayPath = fullPath.substring(bikesIndex + 7, paintsIndex);
      const pathParts = displayPath.split('/');
      const folderName = pathParts[pathParts.length - 1];
      const details = parseFolderName(folderName);
      const modifiedDate = new Date(entry.server_modified);
      const formattedDate = formatModifiedDate(entry.server_modified);
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${entry.name.replace('.pnt', '')}</td>
        <td>${details.type}</td>
        <td>${details.brand}</td>
        <td>${details.make}</td>
        <td>${details.year}</td>
        <td>${formattedDate}</td>
        <td>
          <small style="font-size: 0.8em; color: #666; display: block; margin-bottom: 5px;">
            ${displayPath.replace(/_/g, ' ')}
          </small>
          <button class="select-btn" onclick="event.stopPropagation(); toggleSkinSelection(this.closest('tr'))">
            Select
          </button>
          <button class="download-btn" onclick="downloadSkin('${entry.name}')">
            Download
          </button>
          <button class="action-btn" style="background: #dc3545;" onclick="event.stopPropagation(); showDeleteModal('${fullPath.substring(0, paintsIndex)}', '${entry.name}')">
            Delete
          </button>
        </td>
      `;
      row.classList.add('skin-row');
      row.onclick = () => toggleSkinSelection(row);
      tableBody.appendChild(row);
    }
  });
}
function filterEntriesByTime(entries, timeFilter) {
  if (timeFilter === 'all') return entries;
  const now = new Date();
  const hourMap = {
    '0.5h': 0.5,
    '24h': 24,
    '48h': 48,
    '72h': 72,
    '120h': 120,
    '168h': 168,
    '720h': 720,
    '8760h': 8760
  };
  const hours = hourMap[timeFilter];
  const cutoff = new Date(now - hours * 60 * 60 * 1000);
  return entries.filter(entry => {
    const modifiedDate = new Date(entry.server_modified);
    return modifiedDate >= cutoff;
  });
}
function filterBySearch(entries, searchTerm) {
  if (!searchTerm) return entries;
  searchTerm = searchTerm.toLowerCase();
  return entries.filter(entry => {
    const name = entry.name.toLowerCase();
    const fullPath = entry.path_display;
    const bikesIndex = fullPath.indexOf('/bikes/');
    const pathParts = fullPath.substring(bikesIndex + 7).split('/');
    const folderName = pathParts[0].toLowerCase();
    
    return name.includes(searchTerm) || 
           folderName.includes(searchTerm) ||
           (searchTerm === 'fantic' && (folderName.includes('fantic') || folderName.includes('desmo'))) ||
           (searchTerm === 'beta' && (folderName.includes('beta') || folderName.includes('rx')));
  });
}
async function downloadSkin(filename) {
  try {
    const searchResponse = await dbx.filesSearch({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes`,
      query: filename,
      max_results: 1,
      file_extensions: ['pnt']
    });
    if (searchResponse.result.matches.length === 0) {
      throw new Error('File not found in Dropbox');
    }
    const filePath = searchResponse.result.matches[0].metadata.path_display;
    const sharedLinkResponse = await dbx.sharingCreateSharedLink({
      path: filePath,
      settings: {
        requested_visibility: {
          '.tag': 'public'
        },
        audience: {
          '.tag': 'public'
        },
        access: {
          '.tag': 'viewer'
        }
      }
    });
    const downloadUrl = sharedLinkResponse.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } catch (error) {
    console.error('Error downloading file:', error);
    alert('Error downloading file. Please try again.');
  }
}
document.getElementById('skinForm').addEventListener('submit', async e => {
  e.preventDefault();
  const name = document.getElementById('name').value;
  const type = document.getElementById('type').value;
  const brand = document.getElementById('brand').value;
  const make = document.getElementById('make').value;
  const year = document.getElementById('year').value || null;
  const file = document.getElementById('skinFile').files[0];
  const password = document.getElementById('password').value;
  if (!file) {
    alert('Please select a file to upload');
    return;
  }
  const spinner = e.target.querySelector('.loading-spinner');
  const successMsg = e.target.querySelector('.success-message');
  spinner.style.display = 'block';
  successMsg.style.display = 'none';
  try {
    // Get the correct folder path
    const folderPath = await getFolderPath(type, brand, make, year);
    const fileArrayBuffer = await file.arrayBuffer();

    // Ensure the paints directory exists
    try {
      await dbx.filesCreateFolderBatch({
        paths: [
          `${folderPath}`,
          `${folderPath}/logs`
        ],
        autorename: false
      });
    } catch (error) {
      // Folders may already exist, continue
    }

    // Upload the paint file
    let result;
    try {
      result = await dbx.filesUpload({
        path: `${folderPath}/${file.name}`,
        contents: fileArrayBuffer,
        mode: {
          '.tag': 'overwrite'
        },
        autorename: false
      });
    } catch (uploadError) {
      console.error('Upload error:', uploadError);
      throw uploadError;
    }

    // Generate download link
    let downloadUrl;
    try {
      const sharedLink = await dbx.sharingCreateSharedLink({
        path: result.path_display,
        settings: {
          requested_visibility: {
            '.tag': 'public'
          },
          audience: {
            '.tag': 'public'
          },
          access: {
            '.tag': 'viewer'
          }
        }
      });
      downloadUrl = sharedLink.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
    } catch (error) {
      console.error('Error generating download link:', error);
    }

    // Save form data to logs
    const logData = {
      name,
      type,
      brand,
      make,
      year,
      filename: file.name,
      folderName: folderPath.split('/paints')[0].split('/').pop(), // Get the folder name before 'paints'
      uploadPath: `${folderPath}/${file.name}`,
      password,
      timestamp: new Date().toISOString(),
      uploaderIP: await getUploaderIP(),
      downloadUrl: downloadUrl
    };

    const logFileName = `${type}_${brand}_${make}${year ? '_' + year : ''}_${name}_${file.name}.json`;

    // Save log to bike-specific folder
    await dbx.filesUpload({
      path: `${folderPath}/logs/${logFileName}`,
      contents: JSON.stringify(logData, null, 2),
      mode: {'.tag': 'overwrite'}
    });

    // Save log to global logs folder (3 folders back) 
    await dbx.filesUpload({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/Apps/Logs/${logFileName}`,
      contents: JSON.stringify(logData, null, 2), 
      mode: {'.tag': 'overwrite'}
    });

    let downloadUrl2;
    try {
      const sharedLink = await dbx.sharingCreateSharedLink({
        path: result.path_display,
        settings: {
          requested_visibility: { ".tag": "public" },
          audience: { ".tag": "public" },
          access: { ".tag": "viewer" }
        }
      });
      downloadUrl2 = sharedLink.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
    } catch (error) {
      console.error('Error generating download link:', error);
    }
    await room.collection('skins').create({
      name,
      type,
      brand,
      make,
      year: year ? parseInt(year) : null,
      filename: result.name,
      path: result.path_display,
      downloadUrl: downloadUrl2,
      password: password
    });
    spinner.style.display = 'none';
    successMsg.style.display = 'block';
    initializeDatabase();
    e.target.reset();
    setTimeout(() => {
      successMsg.style.display = 'none';
    }, 3000);
  } catch (error) {
    console.error('Upload error:', error);
    spinner.style.display = 'none';
    alert('Error uploading file. Please check the folder structure and try again.');
  }
});
async function generateDownloadLink(filePath) {
  try {
    const sharedLinkResponse = await dbx.sharingCreateSharedLink({
      path: `${https://www.nckdecals.com/skinhub/}${filePath}`,
      settings: {
        requested_visibility: {
          '.tag': 'public'
        },
        audience: {
          '.tag': 'public'
        },
        access: {
          '.tag': 'viewer'
        }
      }
    });
    return sharedLinkResponse.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
  } catch (error) {
    console.error('Error generating download link:', error);
    return null;
  }
}
room.collection('skins').subscribe(skins => {
  const tableBody = document.getElementById('skinTableBody');
  const timeFilter = document.getElementById('timeFilter').value;
  tableBody.innerHTML = '';
  const skinEntries = [];
  const promises = skins.map(async skin => {
    try {
      const metadata = await dbx.filesGetMetadata({
        path: skin.path
      });
      let downloadUrl = skin.downloadUrl;
      if (!downloadUrl) {
        const sharedLink = await dbx.sharingCreateSharedLink({
          path: skin.path,
          settings: {
            requested_visibility: {
              '.tag': 'public'
            },
            audience: {
              '.tag': 'public'
            },
            access: {
              '.tag': 'viewer'
            }
          }
        });
        downloadUrl = sharedLink.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
        await room.collection('skins').update(skin.id, {
          downloadUrl: downloadUrl
        });
      }
      return {
        skin: {
          ...skin,
          downloadUrl
        },
        metadata: metadata.result
      };
    } catch (error) {
      console.error('Error fetching metadata:', error);
      return null;
    }
  });

  Promise.all(promises).then(results => {
    const validResults = results.filter(result => result !== null);
    
    // Always sort by modified date first (newest to oldest), then apply any other sorting
    const sortBy = document.getElementById('sortBy').value;
    validResults.sort((a, b) => {
      // Default sort by modified date (newest first)
      if (!sortBy || sortBy === 'modified-desc') {
        return new Date(b.metadata.server_modified) - new Date(a.metadata.server_modified);
      }
      
      // Other sort options
      switch (sortBy) {
        case 'modified-asc':
          return new Date(a.metadata.server_modified) - new Date(b.metadata.server_modified);
        case 'name-asc':
          return a.skin.filename.localeCompare(b.skin.filename);
        case 'name-desc':
          return b.skin.filename.localeCompare(a.skin.filename);
        default:
          // Fallback to newest first
          return new Date(b.metadata.server_modified) - new Date(a.metadata.server_modified);
      }
    });

    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    validResults = validResults.filter(result => {
      const filename = result.skin.filename.toLowerCase();
      const fullPath = result.skin.path;
      const bikesIndex = fullPath.indexOf('/bikes/');
      const pathParts = fullPath.substring(bikesIndex + 7).split('/');
      const folderName = pathParts[0].toLowerCase();
      
      return filename.includes(searchTerm) || 
             folderName.includes(searchTerm) ||
             (searchTerm === 'fantic' && (folderName.includes('fantic') || folderName.includes('desmo'))) ||
             (searchTerm === 'beta' && (folderName.includes('beta') || folderName.includes('rx')));
    });

    validResults.forEach(result => {
      const {
        skin,
        metadata
      } = result;
      const fullPath = skin.path;
      const paintsIndex = fullPath.indexOf('/paints');
      const bikesIndex = fullPath.indexOf('/bikes/');
      const displayPath = fullPath.substring(bikesIndex + 7, paintsIndex);
      const pathParts = displayPath.split('/');
      const folderName = pathParts[0];
      const details = parseFolderName(folderName);
      const modifiedDate = new Date(metadata.server_modified);
      const formattedDate = formatModifiedDate(metadata.server_modified);
      const downloadBtnHtml = generateDownloadLink(skin.path) ? `<button class="download-btn" onclick="window.location.href='${generateDownloadLink(skin.path)}'">Download</button>` : `<button class="download-btn" disabled>Link Error</button>`;
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${skin.filename.replace('.pnt', '')}</td>
        <td>${details.type}</td>
        <td>${details.brand}</td>
        <td>${details.make}</td>
        <td>${details.year}</td>
        <td>${formattedDate}</td>
        <td>
          <small style="font-size: 0.8em; color: #666; display: block; margin-bottom: 5px;">
            ${displayPath.replace(/_/g, ' ')}
          </small>
          <button class="select-btn" onclick="event.stopPropagation(); toggleSkinSelection(this.closest('tr'))">
            Select
          </button>
          ${downloadBtnHtml}
          <button class="action-btn" style="background: #dc3545;" onclick="event.stopPropagation(); showDeleteModal('${skin.path}', '${skin.filename}')">
            Delete
          </button>
        </td>
      `;
      row.classList.add('skin-row');
      row.onclick = () => toggleSkinSelection(row);
      tableBody.appendChild(row);
    });
  }).catch(error => {
    console.error('Error processing skins:', error);
  });
});
async function downloadAllSkins() {
  try {
    const timeFilter = document.getElementById('timeFilter').value;
    const sortBy = document.getElementById('sortBy').value;
    const searchTerm = document.getElementById('searchInput').value;
    let downloadUrl = `${https://www.nckdecals.com/skinhub/}download?rlkey=2fs2p8vozopd5dltffwk4em42&st=8hg8d8tj&dl=1`;
    if (timeFilter !== 'all') {
      downloadUrl += `&tf=${timeFilter}`;
    }
    if (sortBy) {
      downloadUrl += `&sort=${sortBy}`;
    }
    if (searchTerm) {
      downloadUrl += `&search=${encodeURIComponent(searchTerm)}`;
    }
    const response = await dbx.filesListFolder({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes`
    });
    const visibleRows = document.querySelectorAll('#skinTableBody tr');
    const visibleFiles = Array.from(visibleRows).map(row => {
      const filePath = row.querySelector('small').textContent.trim();
      const fileName = row.querySelector('td:first-child').textContent + '.pnt';
      return {
        path: filePath,
        name: fileName
      };
    });
    const directoryName = `sorted_paints_${Date.now()}`;
    await dbx.filesCreateFolder({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${directoryName}`
    });
    for (const file of visibleFiles) {
      const sourceFile = await dbx.filesDownload({
        path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${file.path}/paints/${file.name}`
      });
      await dbx.filesUpload({
        path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${directoryName}/${file.name}`,
        contents: sourceFile.result.fileBlob
      });
    }
    const sharedLink = await dbx.sharingCreateSharedLink({
      path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${directoryName}`,
      settings: {
        requested_visibility: {
          '.tag': 'public'
        },
        audience: {
          '.tag': 'public'
        },
        access: {
          '.tag': 'viewer'
        }
      }
    });
    const directoryDownloadUrl = sharedLink.result.url.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
    const a = document.createElement('a');
    a.href = directoryDownloadUrl;
    a.download = `${directoryName}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } catch (error) {
    console.error('Error downloading sorted skins:', error);
    alert('Error downloading sorted skins. Please try again.');
  }
}
async function refreshDatabase() {
  const refreshButton = document.querySelector('.refresh-btn');
  refreshButton.style.pointerEvents = 'none';
  refreshButton.style.opacity = '0.7';
  try {
    await initializeDatabase();
    refreshButton.style.pointerEvents = 'auto';
    refreshButton.style.opacity = '1';
  } catch (error) {
    console.error('Error refreshing database:', error);
    alert('Error refreshing database. Please try again.');
    refreshButton.style.pointerEvents = 'auto';
    refreshButton.style.opacity = '1';
  }
}
function parseFolderName(folderName) {
  const knownBrands = ['Honda', 'Yamaha', 'Kawasaki', 'Suzuki', 'KTM', 'Husqvarna', 'GASGAS', 'CRF', 'Stark'];
  let year = '2024';
  const yearMatch = folderName.match(/\d{4}/);
  if (yearMatch) {
    year = yearMatch[0];
  }

  // Check for Beta or Fantic in folder name first
  let brand = '';
  if (folderName.toLowerCase().includes('beta')) {
    brand = 'Beta';
  } else if (folderName.toLowerCase().includes('fantic') || folderName.toLowerCase().includes('desmo')) {
    brand = 'Fantic';
  } else {
    // Fall back to checking other brands
    for (const knownBrand of knownBrands) {
      if (folderName.toLowerCase().includes(knownBrand.toLowerCase())) {
        brand = knownBrand === 'CRF' ? 'Honda' : knownBrand;
        break;
      }
    }
  }

  // Rest of function remains the same...
  let make = '';
  const folderNameSpaces = folderName.replace(/_/g, ' ');
  for (const validMake of validMakes) {
    if (folderNameSpaces.toLowerCase().includes(validMake.toLowerCase())) {
      make = validMake;
      break;
    }
  }
  
  let type = 'Unknown';
  if (folderName.toLowerCase().includes('oem')) {
    type = 'OEM';
  } else if (folderName.toLowerCase().includes('ak')) {
    type = 'AKIT';
  } else if (folderName.toLowerCase().includes('big bore')) {
    type = 'BIG BORE';
  }

  return {
    type: type,
    brand: brand || 'Unknown',
    make: make || 'Unknown', 
    year: year
  };
}
function parseLogFilename(filename) {
  const parts = filename.split('_');
  return {
    type: parts[0] || '',
    brand: parts[1] || '',
    make: parts[2] || '',
    year: parts[3] || '',
    name: parts[4] || '',
    filename: parts[5] || ''
  };
}
document.getElementById('timeFilter').addEventListener('change', async function () {
  await initializeDatabase();
});
document.getElementById('searchInput').addEventListener('input', async function () {
  await initializeDatabase();
});
document.getElementById('sortBy').addEventListener('change', async function () {
  if (this.value) {
    await initializeDatabase();
  }
});
let selectedSkins = new Set();
async function downloadSelectedSkins() {
  try {
    const selectedSkinsArray = Array.from(selectedSkins).map(s => JSON.parse(s));
    
    for (const skin of selectedSkinsArray) {
      const sourceFile = await dbx.filesDownload({
        path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${skin.path}/paints/${skin.name}`
      });
      
      const sharedLink = await dbx.sharingCreateSharedLink({
        path: `${https://www.nckdecals.com/skinhub/}Apps/MXBSKINS/mods/bikes/${skin.path}/paints/${skin.name}`,
        settings: {
          requested_visibility: { ".tag": "public" },
          audience: { ".tag": "public" },
          access: { ".tag": "viewer" }
        }
      });

      const fileId = sharedLink.result.url.split('/')[4]; 
      const directDownloadUrl = `https://www.dropbox.com/s/${fileId}?dl=1`;

      const a = document.createElement('a');
      a.href = directDownloadUrl;
      a.target = '_blank'; 
      a.click();
    }

    selectedSkins.clear();
    document.querySelectorAll('.skin-row.selected').forEach(row => {
      row.classList.remove('selected');
      const selectBtn = row.querySelector('.select-btn');
      selectBtn.classList.remove('selected');
      selectBtn.textContent = 'Select';
    });
    document.getElementById('downloadSelectedBtn').disabled = true;

  } catch (error) {
    console.error('Error downloading selected skins:', error);
    alert('Error downloading selected skins. Please try again.');
  }
}

function toggleSkinSelection(row) {
  row.classList.toggle('selected');
  const selectBtn = row.querySelector('.select-btn');
  selectBtn.classList.toggle('selected');
  selectBtn.textContent = row.classList.contains('selected') ? 'Selected' : 'Select';
  
  const downloadBtn = document.getElementById('downloadSelectedBtn');
  const skinPath = row.querySelector('small').textContent.trim();
  const skinName = row.querySelector('td:first-child').textContent + '.pnt';
  const skinData = {
    path: skinPath,
    name: skinName
  };
  
  if (row.classList.contains('selected')) {
    selectedSkins.add(JSON.stringify(skinData));
  } else {
    selectedSkins.delete(JSON.stringify(skinData));
  }
  
  downloadBtn.disabled = selectedSkins.size === 0;
}

function formatModifiedDate(date) {
  const now = new Date();
  const diffInSeconds = Math.floor((now - new Date(date)) / 1000);
  
  if (diffInSeconds < 60) { 
    return "uploaded now";
  }
  
  return new Date(date).toLocaleString();
}
document.querySelectorAll('th.sortable').forEach(th => {
  th.addEventListener('click', () => {
    const column = th.dataset.sort;
    
    // Toggle sort direction if clicking same column
    if (currentSort.column === column) {
      currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
      currentSort.column = column;
      currentSort.direction = 'asc'; 
    }

    // Update sort arrows
    document.querySelectorAll('th.sortable').forEach(header => {
      header.classList.remove('asc', 'desc');
    });
    th.classList.add(currentSort.direction);

    // Trigger database refresh with new sort
    initializeDatabase();
  });
});
initializeDatabase();
</script>

</body></html>
